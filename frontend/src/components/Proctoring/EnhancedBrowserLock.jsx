import React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { toast } from 'react-toastify';\nimport './BrowserLock.css';\n\nconst EnhancedBrowserLock = ({ \n  isActive, \n  onViolation, \n  onStatusChange,\n  examId, \n  studentId,\n  securityLevel = 'strict',\n  enableVirtualMachineDetection = true,\n  enablePrintScreenBlocking = true,\n  enableCopyPasteBlocking = true\n}) => {\n  // State Management\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  const [violations, setViolations] = useState([]);\n  const [wakeLock, setWakeLock] = useState(null);\n  const [systemInfo, setSystemInfo] = useState(null);\n  const [isVirtualMachine, setIsVirtualMachine] = useState(false);\n  const [suspiciousActivity, setSuspiciousActivity] = useState(0);\n  \n  // Refs for tracking\n  const windowFocusRef = useRef(true);\n  const lastActivityRef = useRef(Date.now());\n  const violationCooldownRef = useRef(new Set());\n  const printScreenOverlayRef = useRef(null);\n  const devToolsOpenRef = useRef(false);\n  const urlChangeDetectorRef = useRef(null);\n\n  // Violation types with enhanced categories\n  const VIOLATION_TYPES = {\n    TAB_SWITCH: 'tab-switch',\n    FULLSCREEN_EXIT: 'fullscreen-exit',\n    RIGHT_CLICK: 'right-click',\n    COPY_PASTE: 'copy-paste-attempt',\n    DEV_TOOLS: 'developer-tools',\n    SCREEN_CAPTURE: 'screen-capture-attempt',\n    MULTIPLE_MONITORS: 'multiple-monitors',\n    WINDOW_RESIZE: 'suspicious-window-resize',\n    SUSPICIOUS_ACTIVITY: 'suspicious-inactivity',\n    PRINT_SCREEN: 'print-screen-attempt',\n    VM_ENVIRONMENT: 'vm-environment-detected',\n    URL_MANIPULATION: 'url-manipulation',\n    CONSOLE_ACCESS: 'console-access-attempt',\n    EXTENSIONS_DETECTED: 'browser-extensions'\n  };\n\n  // Security severity levels\n  const getViolationSeverity = (type) => {\n    switch (type) {\n      case VIOLATION_TYPES.TAB_SWITCH:\n      case VIOLATION_TYPES.FULLSCREEN_EXIT:\n      case VIOLATION_TYPES.DEV_TOOLS:\n      case VIOLATION_TYPES.SCREEN_CAPTURE:\n      case VIOLATION_TYPES.CONSOLE_ACCESS:\n        return 3; // Critical\n      case VIOLATION_TYPES.RIGHT_CLICK:\n      case VIOLATION_TYPES.COPY_PASTE:\n      case VIOLATION_TYPES.PRINT_SCREEN:\n      case VIOLATION_TYPES.URL_MANIPULATION:\n        return 2; // Major\n      case VIOLATION_TYPES.VM_ENVIRONMENT:\n      case VIOLATION_TYPES.MULTIPLE_MONITORS:\n      case VIOLATION_TYPES.WINDOW_RESIZE:\n        return 1; // Minor\n      default:\n        return 1;\n    }\n  };\n\n  // Enhanced violation messages\n  const getViolationMessage = (type) => {\n    switch (type) {\n      case VIOLATION_TYPES.TAB_SWITCH:\n        return 'Tab switching or window switching detected!';\n      case VIOLATION_TYPES.FULLSCREEN_EXIT:\n        return 'Fullscreen mode is required for exam security!';\n      case VIOLATION_TYPES.RIGHT_CLICK:\n        return 'Right-click context menu is disabled during exam.';\n      case VIOLATION_TYPES.COPY_PASTE:\n        return 'Copy/paste operations are blocked during exam.';\n      case VIOLATION_TYPES.DEV_TOOLS:\n        return 'Developer tools access detected!';\n      case VIOLATION_TYPES.SCREEN_CAPTURE:\n        return 'Screen recording or capture attempt blocked!';\n      case VIOLATION_TYPES.PRINT_SCREEN:\n        return 'Screenshot attempt blocked for security.';\n      case VIOLATION_TYPES.VM_ENVIRONMENT:\n        return 'Virtual machine environment detected.';\n      case VIOLATION_TYPES.URL_MANIPULATION:\n        return 'URL tampering detected!';\n      case VIOLATION_TYPES.CONSOLE_ACCESS:\n        return 'Browser console access attempt detected!';\n      default:\n        return 'Security violation detected.';\n    }\n  };\n\n  // Advanced violation logging with cooldown and severity scoring\n  const logViolation = useCallback((type, details = {}) => {\n    const violationKey = `${type}-${Math.floor(Date.now() / 5000)}`; // 5 second cooldown window\n    \n    if (violationCooldownRef.current.has(violationKey)) {\n      return;\n    }\n    \n    violationCooldownRef.current.add(violationKey);\n    setTimeout(() => {\n      violationCooldownRef.current.delete(violationKey);\n    }, 5000);\n\n    const severity = getViolationSeverity(type);\n    const violation = {\n      id: `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      type,\n      message: getViolationMessage(type),\n      timestamp: new Date(),\n      examId,\n      studentId,\n      details: {\n        ...details,\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n        screenResolution: `${screen.width}x${screen.height}`,\n        windowSize: `${window.innerWidth}x${window.innerHeight}`,\n        isFullscreen,\n        suspiciousActivityScore: suspiciousActivity\n      },\n      severity\n    };\n\n    setViolations(prev => [...prev, violation]);\n    setSuspiciousActivity(prev => prev + severity);\n    \n    // Report to parent component\n    if (onViolation) {\n      onViolation(violation);\n    }\n\n    // Update status if too many violations\n    if (onStatusChange && suspiciousActivity + severity > 10) {\n      onStatusChange('error');\n    }\n\n    // Show toast notification based on severity\n    const message = getViolationMessage(type);\n    if (severity >= 3) {\n      toast.error(`ğŸš¨ ${message}`);\n    } else if (severity >= 2) {\n      toast.warn(`âš ï¸ ${message}`);\n    } else {\n      toast.info(`â„¹ï¸ ${message}`);\n    }\n\n    console.warn('ğŸ”’ Security Violation:', violation);\n  }, [examId, studentId, onViolation, onStatusChange, isFullscreen, suspiciousActivity]);\n\n  // Enhanced fullscreen management\n  const enterFullscreen = useCallback(async () => {\n    try {\n      const elem = document.documentElement;\n      if (elem.requestFullscreen) {\n        await elem.requestFullscreen();\n      } else if (elem.webkitRequestFullscreen) {\n        await elem.webkitRequestFullscreen();\n      } else if (elem.msRequestFullscreen) {\n        await elem.msRequestFullscreen();\n      } else if (elem.mozRequestFullScreen) {\n        await elem.mozRequestFullScreen();\n      }\n    } catch (error) {\n      console.error('Fullscreen request failed:', error);\n      logViolation(VIOLATION_TYPES.FULLSCREEN_EXIT, { error: error.message });\n      toast.error('Unable to enter secure mode. Please try again.');\n    }\n  }, [logViolation]);\n\n  const exitFullscreen = useCallback(async () => {\n    try {\n      if (document.exitFullscreen) {\n        await document.exitFullscreen();\n      } else if (document.webkitExitFullscreen) {\n        await document.webkitExitFullscreen();\n      } else if (document.msExitFullscreen) {\n        await document.msExitFullscreen();\n      } else if (document.mozCancelFullScreen) {\n        await document.mozCancelFullScreen();\n      }\n    } catch (error) {\n      console.error('Fullscreen exit failed:', error);\n    }\n  }, []);\n\n  // Enhanced wake lock with error handling\n  const requestWakeLock = useCallback(async () => {\n    try {\n      if ('wakeLock' in navigator) {\n        const wakeLockObj = await navigator.wakeLock.request('screen');\n        setWakeLock(wakeLockObj);\n        console.log('ğŸ”’ Screen wake lock activated');\n        \n        wakeLockObj.addEventListener('release', () => {\n          console.log('ğŸ”’ Wake lock was released');\n          setWakeLock(null);\n        });\n      }\n    } catch (error) {\n      console.error('Wake lock request failed:', error);\n    }\n  }, []);\n\n  const releaseWakeLock = useCallback(async () => {\n    if (wakeLock && wakeLock.release) {\n      try {\n        await wakeLock.release();\n        setWakeLock(null);\n        console.log('ğŸ”’ Screen wake lock released');\n      } catch (error) {\n        console.error('Wake lock release failed:', error);\n      }\n    }\n  }, [wakeLock]);\n\n  // Advanced VM detection with multiple heuristics\n  const detectVirtualMachine = useCallback(() => {\n    if (!enableVirtualMachineDetection) return;\n\n    try {\n      const tests = {\n        userAgent: false,\n        webgl: false,\n        hardware: false,\n        timing: false\n      };\n\n      // User Agent Analysis\n      const ua = navigator.userAgent.toLowerCase();\n      const vmIndicators = ['virtualbox', 'vmware', 'qemu', 'xen', 'parallels', 'hyper-v', 'vbox'];\n      tests.userAgent = vmIndicators.some(indicator => ua.includes(indicator));\n\n      // WebGL Renderer Detection\n      try {\n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n        if (gl) {\n          const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');\n          if (debugInfo) {\n            const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || '';\n            const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || '';\n            const vmGpuIndicators = [\n              'virtualbox', 'vmware', 'microsoft basic render', 'chromium', \n              'llvmpipe', 'software rasterizer'\n            ];\n            tests.webgl = vmGpuIndicators.some(indicator => \n              renderer.toLowerCase().includes(indicator) || vendor.toLowerCase().includes(indicator)\n            );\n            \n            setSystemInfo(prev => ({ ...prev, renderer, vendor }));\n          }\n        }\n      } catch (e) {\n        // WebGL not available or blocked\n      }\n\n      // Hardware Concurrency (VMs often have limited cores)\n      const cores = navigator.hardwareConcurrency;\n      tests.hardware = cores && cores <= 2;\n\n      // Performance timing (VMs often show different timing characteristics)\n      try {\n        const start = performance.now();\n        for (let i = 0; i < 100000; i++) {\n          Math.random();\n        }\n        const end = performance.now();\n        tests.timing = (end - start) > 50; // Suspiciously slow\n      } catch (e) {\n        // Performance API not available\n      }\n\n      const vmDetected = Object.values(tests).filter(Boolean).length >= 2;\n      setIsVirtualMachine(vmDetected);\n\n      if (vmDetected) {\n        logViolation(VIOLATION_TYPES.VM_ENVIRONMENT, { tests, cores });\n      }\n\n      setSystemInfo(prev => ({\n        ...prev,\n        userAgent: navigator.userAgent,\n        cores,\n        vmTests: tests,\n        vmDetected\n      }));\n\n    } catch (error) {\n      console.error('VM detection failed:', error);\n    }\n  }, [enableVirtualMachineDetection, logViolation]);\n\n  // Print screen deterrent overlay\n  const showPrintScreenOverlay = useCallback(() => {\n    if (!enablePrintScreenBlocking) return;\n    \n    try {\n      if (!printScreenOverlayRef.current) {\n        const overlay = document.createElement('div');\n        overlay.className = 'print-screen-overlay';\n        overlay.innerHTML = `\n          <div class=\"overlay-content\">\n            <h2>ğŸš« Screenshot Blocked</h2>\n            <p>Screenshots are not allowed during exam</p>\n          </div>\n        `;\n        document.body.appendChild(overlay);\n        printScreenOverlayRef.current = overlay;\n      }\n      \n      const overlay = printScreenOverlayRef.current;\n      overlay.style.display = 'flex';\n      overlay.classList.add('visible');\n      \n      setTimeout(() => {\n        overlay.classList.remove('visible');\n        setTimeout(() => {\n          overlay.style.display = 'none';\n        }, 300);\n      }, 2000);\n    } catch (error) {\n      console.error('Print screen overlay failed:', error);\n    }\n  }, [enablePrintScreenBlocking]);\n\n  // Enhanced developer tools detection\n  const detectDevTools = useCallback(() => {\n    let devtools = {\n      open: false,\n      orientation: null\n    };\n    \n    const threshold = 160;\n    let heightThreshold = window.outerHeight - window.innerHeight > threshold;\n    let widthThreshold = window.outerWidth - window.innerWidth > threshold;\n    \n    if (!(heightThreshold && widthThreshold) &&\n        ((window.Firebug && window.Firebug.chrome && window.Firebug.chrome.isInitialized) || heightThreshold || widthThreshold)) {\n      \n      if (!devToolsOpenRef.current) {\n        devtools.open = true;\n        devtools.orientation = widthThreshold ? 'vertical' : 'horizontal';\n        devToolsOpenRef.current = true;\n        logViolation(VIOLATION_TYPES.DEV_TOOLS, { orientation: devtools.orientation });\n      }\n    } else {\n      devToolsOpenRef.current = false;\n    }\n  }, [logViolation]);\n\n  // Console access detection\n  const setupConsoleProtection = useCallback(() => {\n    try {\n      // Override console methods to detect usage\n      const originalConsole = { ...console };\n      const consoleOverrides = ['log', 'warn', 'error', 'info', 'debug'];\n      \n      consoleOverrides.forEach(method => {\n        console[method] = function(...args) {\n          logViolation(VIOLATION_TYPES.CONSOLE_ACCESS, { method, argsLength: args.length });\n          return originalConsole[method].apply(console, args);\n        };\n      });\n    } catch (error) {\n      console.error('Console protection setup failed:', error);\n    }\n  }, [logViolation]);\n\n  // URL manipulation detection\n  const detectURLManipulation = useCallback(() => {\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    \n    history.pushState = function(...args) {\n      logViolation(VIOLATION_TYPES.URL_MANIPULATION, { method: 'pushState', url: args[2] });\n      return originalPushState.apply(history, args);\n    };\n    \n    history.replaceState = function(...args) {\n      logViolation(VIOLATION_TYPES.URL_MANIPULATION, { method: 'replaceState', url: args[2] });\n      return originalReplaceState.apply(history, args);\n    };\n    \n    window.addEventListener('popstate', () => {\n      logViolation(VIOLATION_TYPES.URL_MANIPULATION, { method: 'popstate' });\n    });\n  }, [logViolation]);\n\n  // Event handlers with enhanced detection\n  const handleFullscreenChange = useCallback(() => {\n    const isCurrentlyFullscreen = !!(document.fullscreenElement ||\n      document.webkitFullscreenElement ||\n      document.msFullscreenElement ||\n      document.mozFullScreenElement);\n    \n    setIsFullscreen(isCurrentlyFullscreen);\n    \n    if (isActive && !isCurrentlyFullscreen) {\n      logViolation(VIOLATION_TYPES.FULLSCREEN_EXIT, {\n        method: 'fullscreenchange_event'\n      });\n      // Attempt to re-enter fullscreen\n      setTimeout(enterFullscreen, 1000);\n    }\n  }, [isActive, logViolation, enterFullscreen]);\n\n  const handleVisibilityChange = useCallback(() => {\n    if (isActive && document.hidden) {\n      windowFocusRef.current = false;\n      logViolation(VIOLATION_TYPES.TAB_SWITCH, {\n        hidden: document.hidden,\n        visibilityState: document.visibilityState,\n        method: 'visibility_api'\n      });\n    } else {\n      windowFocusRef.current = true;\n      lastActivityRef.current = Date.now();\n    }\n  }, [isActive, logViolation]);\n\n  const handleWindowFocus = useCallback(() => {\n    windowFocusRef.current = true;\n    lastActivityRef.current = Date.now();\n  }, []);\n\n  const handleWindowBlur = useCallback(() => {\n    if (isActive) {\n      windowFocusRef.current = false;\n      logViolation(VIOLATION_TYPES.TAB_SWITCH, {\n        reason: 'window_blur',\n        timestamp: Date.now()\n      });\n    }\n  }, [isActive, logViolation]);\n\n  const handleContextMenu = useCallback((e) => {\n    if (isActive) {\n      e.preventDefault();\n      e.stopPropagation();\n      logViolation(VIOLATION_TYPES.RIGHT_CLICK, {\n        target: e.target.tagName,\n        coordinates: { x: e.clientX, y: e.clientY },\n        button: e.button\n      });\n      return false;\n    }\n  }, [isActive, logViolation]);\n\n  const handleKeyDown = useCallback((e) => {\n    if (!isActive) return;\n\n    const { key, ctrlKey, metaKey, altKey, shiftKey, code } = e;\n    \n    // Enhanced blocked keys\n    const blockedKeys = [\n      'F12', 'F5', 'PrintScreen',\n      'F1', 'F3', 'F6', 'F7' // Additional function keys\n    ];\n\n    // Enhanced blocked combinations\n    const blockedCombinations = [\n      { ctrl: true, key: 'c' }, // Copy\n      { ctrl: true, key: 'v' }, // Paste\n      { ctrl: true, key: 'x' }, // Cut\n      { ctrl: true, key: 'a' }, // Select all\n      { ctrl: true, key: 'f' }, // Find\n      { ctrl: true, key: 'h' }, // History\n      { ctrl: true, key: 'r' }, // Refresh\n      { ctrl: true, key: 's' }, // Save\n      { ctrl: true, key: 'p' }, // Print\n      { ctrl: true, key: 'u' }, // View source\n      { ctrl: true, key: 'w' }, // Close tab\n      { ctrl: true, key: 't' }, // New tab\n      { ctrl: true, key: 'n' }, // New window\n      { ctrl: true, shift: true, key: 'I' }, // Dev tools\n      { ctrl: true, shift: true, key: 'J' }, // Console\n      { ctrl: true, shift: true, key: 'C' }, // Inspector\n      { ctrl: true, shift: true, key: 'Delete' }, // Clear data\n      { alt: true, key: 'Tab' }, // Alt+Tab\n      { alt: true, key: 'F4' }, // Close window\n      { meta: true, key: 'Tab' }, // Cmd+Tab (Mac)\n    ];\n\n    // Check blocked keys\n    if (blockedKeys.includes(key) || blockedKeys.includes(code)) {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      if (key === 'F12') {\n        logViolation(VIOLATION_TYPES.DEV_TOOLS, { key, code, method: 'F12_key' });\n      } else if (key === 'PrintScreen') {\n        logViolation(VIOLATION_TYPES.PRINT_SCREEN, { key, code });\n        showPrintScreenOverlay();\n      }\n      return false;\n    }\n\n    // Check blocked combinations\n    for (const combo of blockedCombinations) {\n      const ctrlOrMeta = (combo.ctrl && (ctrlKey || metaKey)) || (combo.meta && metaKey);\n      if (!ctrlOrMeta) continue;\n      if (combo.shift && !shiftKey) continue;\n      if (!combo.shift && shiftKey && ['I', 'J', 'C'].includes(combo.key)) continue;\n      if (combo.alt && !altKey) continue;\n      \n      if (combo.key.toLowerCase() === key.toLowerCase()) {\n        e.preventDefault();\n        e.stopPropagation();\n        \n        if (enableCopyPasteBlocking && ['c', 'v', 'x', 'a'].includes(combo.key)) {\n          logViolation(VIOLATION_TYPES.COPY_PASTE, { \n            key, \n            combination: `${ctrlKey ? 'Ctrl+' : 'Cmd+'}${key}`,\n            code \n          });\n        } else if (['I', 'J', 'C'].includes(combo.key) && shiftKey) {\n          logViolation(VIOLATION_TYPES.DEV_TOOLS, { \n            key, \n            combination: `Ctrl+Shift+${key}`,\n            code \n          });\n        }\n        return false;\n      }\n    }\n\n    // Track activity\n    lastActivityRef.current = Date.now();\n  }, [isActive, logViolation, enableCopyPasteBlocking, showPrintScreenOverlay]);\n\n  const handleWindowResize = useCallback(() => {\n    if (isActive) {\n      const { innerWidth, innerHeight } = window;\n      const { availWidth, availHeight } = window.screen;\n      \n      // More sophisticated multi-monitor detection\n      if (innerWidth < availWidth * 0.8 || innerHeight < availHeight * 0.8) {\n        logViolation(VIOLATION_TYPES.WINDOW_RESIZE, {\n          windowSize: { width: innerWidth, height: innerHeight },\n          screenSize: { width: availWidth, height: availHeight },\n          ratio: { \n            width: (innerWidth / availWidth).toFixed(2), \n            height: (innerHeight / availHeight).toFixed(2) \n          }\n        });\n      }\n      \n      // Check for dev tools\n      detectDevTools();\n    }\n  }, [isActive, logViolation, detectDevTools]);\n\n  // Enhanced screen recording detection\n  const setupScreenCaptureProtection = useCallback(() => {\n    if (!navigator.mediaDevices) return;\n    \n    try {\n      // Override getDisplayMedia\n      const originalGetDisplayMedia = navigator.mediaDevices.getDisplayMedia;\n      if (originalGetDisplayMedia) {\n        navigator.mediaDevices.getDisplayMedia = function(constraints) {\n          logViolation(VIOLATION_TYPES.SCREEN_CAPTURE, {\n            method: 'getDisplayMedia',\n            constraints,\n            timestamp: Date.now()\n          });\n          return originalGetDisplayMedia.call(this, constraints);\n        };\n      }\n    } catch (error) {\n      console.error('Screen capture protection setup failed:', error);\n    }\n  }, [logViolation]);\n\n  // Initialize security measures\n  useEffect(() => {\n    if (!isActive) return;\n\n    if (onStatusChange) {\n      onStatusChange('initializing');\n    }\n\n    // Add event listeners\n    const events = [\n      ['fullscreenchange', handleFullscreenChange],\n      ['webkitfullscreenchange', handleFullscreenChange],\n      ['msfullscreenchange', handleFullscreenChange],\n      ['mozfullscreenchange', handleFullscreenChange],\n      ['visibilitychange', handleVisibilityChange],\n      ['contextmenu', handleContextMenu],\n      ['keydown', handleKeyDown],\n    ];\n\n    const windowEvents = [\n      ['focus', handleWindowFocus],\n      ['blur', handleWindowBlur],\n      ['resize', handleWindowResize],\n      ['beforeunload', (e) => {\n        if (isActive) {\n          e.preventDefault();\n          e.returnValue = 'Exam is in progress. Are you sure you want to leave?';\n          logViolation(VIOLATION_TYPES.TAB_SWITCH, { method: 'beforeunload' });\n        }\n      }]\n    ];\n\n    // Add document event listeners\n    events.forEach(([event, handler]) => {\n      document.addEventListener(event, handler, { passive: false });\n    });\n\n    // Add window event listeners  \n    windowEvents.forEach(([event, handler]) => {\n      window.addEventListener(event, handler, { passive: false });\n    });\n\n    // Initialize security measures\n    const initSecurity = async () => {\n      try {\n        await enterFullscreen();\n        await requestWakeLock();\n        detectVirtualMachine();\n        setupScreenCaptureProtection();\n        detectURLManipulation();\n        setupConsoleProtection();\n        \n        // Initial dev tools check\n        setTimeout(detectDevTools, 1000);\n        \n        if (onStatusChange) {\n          onStatusChange('active');\n        }\n      } catch (error) {\n        console.error('Security initialization failed:', error);\n        if (onStatusChange) {\n          onStatusChange('error');\n        }\n      }\n    };\n\n    initSecurity();\n\n    // Cleanup function\n    return () => {\n      // Remove event listeners\n      events.forEach(([event, handler]) => {\n        document.removeEventListener(event, handler);\n      });\n      \n      windowEvents.forEach(([event, handler]) => {\n        window.removeEventListener(event, handler);\n      });\n      \n      // Release wake lock\n      releaseWakeLock();\n      \n      // Remove print screen overlay\n      if (printScreenOverlayRef.current) {\n        try {\n          document.body.removeChild(printScreenOverlayRef.current);\n        } catch (e) {\n          // Element might already be removed\n        }\n        printScreenOverlayRef.current = null;\n      }\n      \n      if (onStatusChange) {\n        onStatusChange('inactive');\n      }\n    };\n  }, [isActive, handleFullscreenChange, handleVisibilityChange, handleWindowFocus, \n      handleWindowBlur, handleContextMenu, handleKeyDown, handleWindowResize,\n      enterFullscreen, requestWakeLock, detectVirtualMachine, \n      setupScreenCaptureProtection, detectURLManipulation, setupConsoleProtection,\n      detectDevTools, releaseWakeLock, onStatusChange, logViolation]);\n\n  // Periodic security checks\n  useEffect(() => {\n    if (!isActive) return;\n\n    const securityInterval = setInterval(() => {\n      const now = Date.now();\n      const timeSinceLastActivity = now - lastActivityRef.current;\n      \n      // Check for extended inactivity\n      if (timeSinceLastActivity > 5 * 60 * 1000) { // 5 minutes\n        logViolation(VIOLATION_TYPES.SUSPICIOUS_ACTIVITY, {\n          reason: 'extended_inactivity',\n          duration: timeSinceLastActivity,\n          lastActivity: new Date(lastActivityRef.current).toISOString()\n        });\n      }\n      \n      // Periodic dev tools check\n      detectDevTools();\n      \n      // Check if fullscreen was somehow exited\n      const isCurrentlyFullscreen = !!(document.fullscreenElement ||\n        document.webkitFullscreenElement ||\n        document.msFullscreenElement ||\n        document.mozFullScreenElement);\n      \n      if (!isCurrentlyFullscreen && isFullscreen) {\n        logViolation(VIOLATION_TYPES.FULLSCREEN_EXIT, {\n          method: 'periodic_check',\n          timestamp: now\n        });\n        enterFullscreen();\n      }\n      \n    }, 30000); // Check every 30 seconds\n\n    return () => clearInterval(securityInterval);\n  }, [isActive, logViolation, detectDevTools, isFullscreen, enterFullscreen]);\n\n  // Don't render if not active\n  if (!isActive) {\n    return null;\n  }\n\n  return (\n    <div className=\"browser-lock-overlay\">\n      {/* Security Status Panel */}\n      <div className=\"bl-security-status\">\n        <div className={`bl-status-indicator ${isFullscreen ? 'active' : 'inactive'}`}>\n          <span className=\"bl-status-icon\">\n            {isFullscreen ? 'ğŸ”’' : 'âš ï¸'}\n          </span>\n          <span className=\"bl-status-text\">\n            {isFullscreen ? 'Secure Mode Active' : 'Security Warning'}\n          </span>\n        </div>\n        \n        {violations.length > 0 && (\n          <div className=\"bl-violation-counter\">\n            <span className=\"bl-violation-icon\">âš ï¸</span>\n            <span className=\"bl-violation-count\">{violations.length}</span>\n          </div>\n        )}\n        \n        {suspiciousActivity > 5 && (\n          <div className=\"bl-threat-level\">\n            <span className=\"bl-threat-icon\">ğŸ”´</span>\n            <span className=\"bl-threat-text\">High Alert</span>\n          </div>\n        )}\n      </div>\n\n      {/* VM Environment Notice */}\n      {isVirtualMachine && (\n        <div className=\"bl-vm-notice\" role=\"alert\">\n          <span className=\"bl-vm-icon\">ğŸ–¥ï¸</span>\n          <span className=\"bl-vm-text\">\n            Virtual machine environment detected - monitoring enhanced\n          </span>\n        </div>\n      )}\n\n      {/* Fullscreen Requirement Overlay */}\n      {!isFullscreen && (\n        <div className=\"bl-fullscreen-prompt\">\n          <div className=\"bl-prompt-content\">\n            <div className=\"bl-security-icon\">ğŸ”’</div>\n            <h2>Secure Exam Mode Required</h2>\n            <p>\n              This exam requires fullscreen mode for security and proctoring.\n              Click the button below to enter secure mode.\n            </p>\n            <div className=\"bl-security-features\">\n              <div className=\"bl-feature\">\n                <span className=\"bl-feature-icon\">ğŸ‘ï¸</span>\n                <span>Continuous monitoring</span>\n              </div>\n              <div className=\"bl-feature\">\n                <span className=\"bl-feature-icon\">ğŸ”’</span>\n                <span>Browser restrictions</span>\n              </div>\n              <div className=\"bl-feature\">\n                <span className=\"bl-feature-icon\">ğŸ“µ</span>\n                <span>Screenshot prevention</span>\n              </div>\n            </div>\n            <button \n              className=\"bl-fullscreen-btn\"\n              onClick={enterFullscreen}\n              aria-label=\"Enter secure exam mode\"\n            >\n              ğŸš€ Enter Secure Mode\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default EnhancedBrowserLock;